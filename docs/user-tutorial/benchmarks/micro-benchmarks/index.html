<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.1">
<link rel="alternate" type="application/rss+xml" href="/superbenchmark/blog/rss.xml" title="SuperBench Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/superbenchmark/blog/atom.xml" title="SuperBench Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="SuperBench" href="/superbenchmark/opensearch.xml"><title data-react-helmet="true">Micro Benchmarks | SuperBench</title><meta data-react-helmet="true" property="og:url" content="https://microsoft.github.io/superbenchmark/docs/user-tutorial/benchmarks/micro-benchmarks"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Micro Benchmarks | SuperBench"><meta data-react-helmet="true" name="description" content="Computation Benchmarks"><meta data-react-helmet="true" property="og:description" content="Computation Benchmarks"><link data-react-helmet="true" rel="shortcut icon" href="/superbenchmark/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://microsoft.github.io/superbenchmark/docs/user-tutorial/benchmarks/micro-benchmarks"><link data-react-helmet="true" rel="alternate" href="https://microsoft.github.io/superbenchmark/docs/user-tutorial/benchmarks/micro-benchmarks" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://microsoft.github.io/superbenchmark/docs/user-tutorial/benchmarks/micro-benchmarks" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/superbenchmark/assets/css/styles.3d1af2f1.css">
<link rel="preload" href="/superbenchmark/assets/js/runtime~main.45f631de.js" as="script">
<link rel="preload" href="/superbenchmark/assets/js/main.74900b60.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_OuoZ shadow--md">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/superbenchmark/"><img src="/superbenchmark/img/logo.svg" alt="Docusaurus Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/superbenchmark/img/logo.svg" alt="Docusaurus Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">SuperBench</b></a><a class="navbar__item navbar__link navbar__link--active" href="/superbenchmark/docs/introduction">Docs</a><a class="navbar__item navbar__link" href="/superbenchmark/docs/cli">API</a><a class="navbar__item navbar__link" href="/superbenchmark/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/microsoft/superbenchmark" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_cxYs react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_Bc3W"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/superbenchmark/"><img src="/superbenchmark/img/logo.svg" alt="Docusaurus Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/superbenchmark/img/logo.svg" alt="Docusaurus Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">SuperBench</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/superbenchmark/docs/introduction">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/superbenchmark/docs/cli">API</a></li><li class="menu__list-item"><a class="menu__link" href="/superbenchmark/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/microsoft/superbenchmark" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_lDyR"><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu menu--responsive thin-scrollbar menu_cyFh" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_iZzd" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/superbenchmark/docs/introduction">Introduction</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist" href="#!">Getting Started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/getting-started/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/getting-started/configuration">Configuration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/getting-started/run-superbench">Run SuperBench</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">User Tutorial</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Benchmarks</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/superbenchmark/docs/user-tutorial/benchmarks/micro-benchmarks">Micro Benchmarks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/benchmarks/model-benchmarks">Model Benchmarks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/benchmarks/docker-benchmarks">Docker Benchmarks</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/system-config">System Config Info</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/data-diagnosis">Data Diagnosis</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/result-summary">Result Summary</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/baseline-generation">Baseline Generation</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/monitor">Monitor</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/superbenchmark/docs/user-tutorial/container-images">Container Images</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Developer Guides</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/superbenchmark/docs/developer-guides/development">Development</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/superbenchmark/docs/developer-guides/using-docker">Using Docker</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/superbenchmark/docs/developer-guides/contributing">Contributing</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Design Docs</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/superbenchmark/docs/design-docs/overview">Superbench Design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/superbenchmark/docs/design-docs/benchmarks">Benchmarks Design</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg docItemWrapper_NJLN"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="markdown"><header><h1 class="h1Heading_dC7a">Micro Benchmarks</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="computation-benchmarks"></a>Computation Benchmarks<a class="hash-link" href="#computation-benchmarks" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="kernel-launch"></a><code>kernel-launch</code><a class="hash-link" href="#kernel-launch" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction"></a>Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">#</a></h4><p>Measure GPU kernel launch latency,
which is defined as the time range from the beginning of the launch API call to the beginning of the kernel execution.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics"></a>Metrics<a class="hash-link" href="#metrics" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>kernel-launch/event_time</td><td>time (ms)</td><td>Launch latency measured in GPU time.</td></tr><tr><td>kernel-launch/wall_time</td><td>time (ms)</td><td>Launch latency measured in CPU time.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="gemm-flops"></a><code>gemm-flops</code><a class="hash-link" href="#gemm-flops" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-1"></a>Introduction<a class="hash-link" href="#introduction-1" title="Direct link to heading">#</a></h4><p>Measure the GPU GEMM FLOPS for different float and int data types, with or without Tensor Core (XDLOPS),
performed by NVIDIA <a href="https://github.com/NVIDIA/cutlass/tree/ccb697bac77fcc898e9c897b2c90aa5b60ac72fb" target="_blank" rel="noopener noreferrer">cutlass</a>
or AMD <a href="https://github.com/ROCmSoftwarePlatform/rocBLAS/tree/develop/clients/benchmarks" target="_blank" rel="noopener noreferrer">rocblas-bench</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-1"></a>Metrics<a class="hash-link" href="#metrics-1" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>gemm-flops/fp64_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM float64 peak FLOPS.</td></tr><tr><td>gemm-flops/fp32_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM float32 peak FLOPS.</td></tr><tr><td>gemm-flops/fp16_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM float16 peak FLOPS.</td></tr><tr><td>gemm-flops/fp64_tc_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM float64 peak FLOPS with NVIDIA Tensor Core.</td></tr><tr><td>gemm-flops/tf32_tc_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM tensor-float32 peak FLOPS with NVIDIA Tensor Core.</td></tr><tr><td>gemm-flops/fp16_tc_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM float16 peak FLOPS with NVIDIA Tensor Core.</td></tr><tr><td>gemm-flops/bf16_tc_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM bfloat16 peak FLOPS with NVIDIA Tensor Core.</td></tr><tr><td>gemm-flops/int8_tc_iops</td><td>IOPS (GIOPS)</td><td>GEMM int8 peak IOPS with NVIDIA Tensor Core.</td></tr><tr><td>gemm-flops/int4_tc_iops</td><td>IOPS (GIOPS)</td><td>GEMM int4 peak IOPS with NVIDIA Tensor Core.</td></tr><tr><td>gemm-flops/fp32_xdlops_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM tensor-float32 peak FLOPS with AMD XDLOPS.</td></tr><tr><td>gemm-flops/fp16_xdlops_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM float16 peak FLOPS with AMD XDLOPS.</td></tr><tr><td>gemm-flops/bf16_xdlops_flops</td><td>FLOPS (GFLOPS)</td><td>GEMM bfloat16 peak FLOPS with AMD XDLOPS.</td></tr><tr><td>gemm-flops/int8_xdlops_iops</td><td>IOPS (GIOPS)</td><td>GEMM int8 peak IOPS with AMD XDLOPS.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="matmul"></a><code>matmul</code><a class="hash-link" href="#matmul" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-2"></a>Introduction<a class="hash-link" href="#introduction-2" title="Direct link to heading">#</a></h4><p>Large scale matmul operation using <code>torch.matmul</code> with one GPU.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-2"></a>Metrics<a class="hash-link" href="#metrics-2" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>pytorch-matmul/nosharding_time</td><td>time (ms)</td><td>Time of pure matmul operation.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="cublaslt-gemm--hipblaslt-gemm"></a><code>cublaslt-gemm</code> / <code>hipblaslt-gemm</code><a class="hash-link" href="#cublaslt-gemm--hipblaslt-gemm" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-3"></a>Introduction<a class="hash-link" href="#introduction-3" title="Direct link to heading">#</a></h4><p>Measure the GEMM performance of <a href="https://docs.nvidia.com/cuda/cublas/#cublasltmatmul" target="_blank" rel="noopener noreferrer"><code>cublasLtMatmul</code></a> or <a href="https://github.com/ROCm/hipBLASLt/blob/develop/clients/benchmarks/README.md" target="_blank" rel="noopener noreferrer"><code>hipblasLt-bench</code></a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-3"></a>Metrics<a class="hash-link" href="#metrics-3" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cublaslt-gemm/${dtype}_${batch}_${m}_${n}_${k}_flops</td><td>FLOPS (TFLOPS)</td><td>TFLOPS of measured GEMM kernel.</td></tr><tr><td>hipblaslt-gemm/${dtype}_${batch}_${m}_${n}_${k}_flops</td><td>FLOPS (TFLOPS)</td><td>TFLOPS of measured GEMM kernel.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="cublas-function"></a><code>cublas-function</code><a class="hash-link" href="#cublas-function" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-4"></a>Introduction<a class="hash-link" href="#introduction-4" title="Direct link to heading">#</a></h4><p>Measure the performance of most common Nvidia cuBLAS functions with parameters in models training including ResNet, VGG, DenseNet, LSTM, BERT, and GPT-2.</p><p>The supported functions for cuBLAS are as follows:</p><ul><li>cublasSgemm</li><li>cublasSgemmStridedBatched</li><li>cublasGemmStridedBatchedEx</li><li>cublasGemmEx</li><li>cublasCgemm3mStridedBatched</li><li>cublasCgemm</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-4"></a>Metrics<a class="hash-link" href="#metrics-4" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cublas-function/name_${function_name}_${parameters}_time</td><td>time (us)</td><td>The mean time to execute the cublas function with the parameters.</td></tr><tr><td>cublas-function/name_${function_name}_${parameters}_correctness</td><td></td><td>Whether the calculation results of executing the cublas function with the parameters pass the correctness check if enable correctness check.</td></tr><tr><td>cublas-function/name_${function_name}_${parameters}_error</td><td></td><td>The error ratio of the calculation results of executing the cublas function with the parameters if enable correctness check.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="cudnn-function"></a><code>cudnn-function</code><a class="hash-link" href="#cudnn-function" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-5"></a>Introduction<a class="hash-link" href="#introduction-5" title="Direct link to heading">#</a></h4><p>Measure the performance of most common Nvidia cuDNN functions with parameters in models training including ResNet, VGG, DenseNet, LSTM, BERT, and GPT-2.</p><p>The supported functions for cuDNN are as follows:</p><ul><li>cudnnConvolutionBackwardFilter</li><li>cudnnConvolutionBackwardData</li><li>cudnnConvolutionForward</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-5"></a>Metrics<a class="hash-link" href="#metrics-5" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cudnn-function/name_${function_name}_${parameters}_time</td><td>time (us)</td><td>The mean time to execute the cudnn function with the parameters.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="tensorrt-inference"></a><code>tensorrt-inference</code><a class="hash-link" href="#tensorrt-inference" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-6"></a>Introduction<a class="hash-link" href="#introduction-6" title="Direct link to heading">#</a></h4><p>Inference PyTorch/ONNX models on NVIDIA GPUs with <a href="https://developer.nvidia.com/tensorrt" target="_blank" rel="noopener noreferrer">TensorRT</a>.</p><p>Currently the following models are supported:</p><blockquote><p>alexnet, densenet121, densenet169, densenet201, densenet161, googlenet, inception_v3, mnasnet0_5,
mnasnet1_0, mobilenet_v2, resnet18, resnet34, resnet50, resnet101, resnet152, resnext50_32x4d,
resnext101_32x8d, wide_resnet50_2, wide_resnet101_2, shufflenet_v2_x0_5, shufflenet_v2_x1_0,
squeezenet1_0, squeezenet1_1, vgg11, vgg11_bn, vgg13, vgg13_bn, vgg16, vgg16_bn, vgg19_bn, vgg19
lstm, bert-base, bert-large, gpt2-small</p></blockquote><blockquote><p>Do not support large models like <code>gpt2-large</code> currently because models larger than 2GB (maximum protobuf size) cannot be exported in one ONNX file.</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-6"></a>Metrics<a class="hash-link" href="#metrics-6" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>tensorrt-inference/${model}_gpu_time_mean</td><td>time (ms)</td><td>The mean GPU latency to execute the kernels for a query.</td></tr><tr><td>tensorrt-inference/${model}_gpu_time_99</td><td>time (ms)</td><td>The 99th percentile GPU latency to execute the kernels for a query.</td></tr><tr><td>tensorrt-inference/${model}_host_time_mean</td><td>time (ms)</td><td>The mean H2D, GPU, and D2H latency to execute the kernels for a query.</td></tr><tr><td>tensorrt-inference/${model}_host_time_99</td><td>time (ms)</td><td>The 99th percentile H2D, GPU, and D2H latency to execute the kernels for a query.</td></tr><tr><td>tensorrt-inference/${model}_end_to_end_time_mean</td><td>time (ms)</td><td>The mean duration from when the H2D of a query is called to when the D2H of the same query is completed.</td></tr><tr><td>tensorrt-inference/${model}_end_to_end_time_99</td><td>time (ms)</td><td>The P99 duration from when the H2D of a query is called to when the D2H of the same query is completed.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ort-inference"></a><code>ort-inference</code><a class="hash-link" href="#ort-inference" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-7"></a>Introduction<a class="hash-link" href="#introduction-7" title="Direct link to heading">#</a></h4><p>Inference performance of the torchvision models using ONNXRuntime. Currently the following models are supported:</p><blockquote><p>alexnet, densenet121, densenet169, densenet201, densenet161, googlenet, inception_v3, mnasnet0_5,
mnasnet1_0, mobilenet_v2, resnet18, resnet34, resnet50, resnet101, resnet152, resnext50_32x4d,
resnext101_32x8d, wide_resnet50_2, wide_resnet101_2, shufflenet_v2_x0_5, shufflenet_v2_x1_0,
squeezenet1_0, squeezenet1_1, vgg11, vgg11_bn, vgg13, vgg13_bn, vgg16, vgg16_bn, vgg19_bn, vgg19</p></blockquote><p>The supported percentiles are 50, 90, 95, 99, and 99.9.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-7"></a>Metrics<a class="hash-link" href="#metrics-7" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>ort-inference/{precision}_{model}_time</td><td>time (ms)</td><td>The mean latency to execute one batch of inference.</td></tr><tr><td>ort-inference/{precision}<em>{model}_time</em>{percentile}</td><td>time (ms)</td><td>The {percentile}th percentile latency to execute one batch of inference.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="gpu-burn"></a><code>gpu-burn</code><a class="hash-link" href="#gpu-burn" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-8"></a>Introduction<a class="hash-link" href="#introduction-8" title="Direct link to heading">#</a></h4><p>Multi-GPU CUDA stress test for GPU compute and memory utilization, performed by <a href="https://github.com/wilicc/gpu-burn" target="_blank" rel="noopener noreferrer">gpu-burn</a>.
Supports the use of double unit types and the use of tensor cores.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-8"></a>Metrics<a class="hash-link" href="#metrics-8" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>gpu-burn/time</td><td>time (s)</td><td>The runtime for gpu-burn test.</td></tr><tr><td>gpu-burn/gpu_[0-9]_pass</td><td>yes/no</td><td>The result of the gpu-burn test for each GPU (1: yes, 0: no).</td></tr><tr><td>gpu-burn/abort</td><td>yes/no</td><td>Whether or not GPU-burn test aborted before returning GPU results (1: yes, 0: no).</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="cpu-hpl"></a><code>cpu-hpl</code><a class="hash-link" href="#cpu-hpl" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-9"></a>Introduction<a class="hash-link" href="#introduction-9" title="Direct link to heading">#</a></h4><p>HPL or High Performance Computing Linpack evaluates compute bandwidth by solving dense linear systems in double precision arethmetic.
Performed by <a href="https://netlib.org/benchmark/hpl/" target="_blank" rel="noopener noreferrer">High-Performance Linpack Benchmark for Distributed-Memory Computers</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-9"></a>Metrics<a class="hash-link" href="#metrics-9" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cpu-hpl/tests_pass</td><td></td><td>HPL completed running and correctness test has passed (1: pass, 0: fail).</td></tr><tr><td>cpu-hpl/throughput</td><td>bandwidth (GFlops)</td><td>Compute bandwidth.</td></tr><tr><td>cpu-hpl/time</td><td>time (s)</td><td>Time elapsed during HPL run.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="cpu-stream"></a><code>cpu-stream</code><a class="hash-link" href="#cpu-stream" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-10"></a>Introduction<a class="hash-link" href="#introduction-10" title="Direct link to heading">#</a></h4><p>Measure of memory bandwidth and computation rate for simple vector kernels.
performed by <a href="https://www.cs.virginia.edu/stream/ref.html" target="_blank" rel="noopener noreferrer">University of Virginia STREAM benchmark</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-10"></a>Metrics<a class="hash-link" href="#metrics-10" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cpu-stream/threads</td><td></td><td>Number of threads used for the test. Determined by core count.</td></tr><tr><td>cpu-stream/[&#x27;copy&#x27;, &#x27;scale&#x27;, &#x27;add&#x27;, &#x27;triad&#x27;]_throughput</td><td>bandwidth (MB/s)</td><td>Memory throughput of designated kerel operation.</td></tr><tr><td>cpu-stream/[&#x27;copy&#x27;, &#x27;scale&#x27;, &#x27;add&#x27;, &#x27;triad&#x27;]_time_avg</td><td>time (s)</td><td>Average elapsed times over all iterations.</td></tr><tr><td>cpu-stream/[&#x27;copy&#x27;, &#x27;scale&#x27;, &#x27;add&#x27;, &#x27;triad&#x27;]_time_min</td><td>time (s)</td><td>Minimum elapsed times over all iterations.</td></tr><tr><td>cpu-stream/[&#x27;copy&#x27;, &#x27;scale&#x27;, &#x27;add&#x27;, &#x27;triad&#x27;]_time_max</td><td>time (s)</td><td>Maximum elapsed times over all iterations.</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="communication-benchmarks"></a>Communication Benchmarks<a class="hash-link" href="#communication-benchmarks" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="cpu-memory-bw-latency"></a><code>cpu-memory-bw-latency</code><a class="hash-link" href="#cpu-memory-bw-latency" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-11"></a>Introduction<a class="hash-link" href="#introduction-11" title="Direct link to heading">#</a></h4><p>Measure the memory copy bandwidth and latency across different CPU NUMA nodes.
performed by <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/intelr-memory-latency-checker.html" target="_blank" rel="noopener noreferrer">Intel MLC Tool</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-11"></a>Metrics<a class="hash-link" href="#metrics-11" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cpu-memory-bw-latency/mem_bandwidth_matrix_numa_[0-9]+_[0-9]+_bw</td><td>bandwidth (MB/s)</td><td>Former NUMA to latter NUMA memory bandwidth.</td></tr><tr><td>cpu-memory-bw-latency/mem_bandwidth_matrix_numa_[0-9]+_[0-9]+_lat</td><td>time (ns)</td><td>Former NUMA to latter NUMA memory latency.</td></tr><tr><td>cpu-memory-bw-latency/mem_max_bandwidth_all_reads_bw</td><td>bandwidth (MB/s)</td><td>Whole-CPU maximum memory bandwidth, full read.</td></tr><tr><td>cpu-memory-bw-latency/mem_max_bandwidth_3_1_reads-writes_bw</td><td>bandwidth (MB/s)</td><td>Whole-CPU maximum memory bandwidth, read : write = 3 : 1.</td></tr><tr><td>cpu-memory-bw-latency/mem_max_bandwidth_2_1_reads-writes_bw</td><td>bandwidth (MB/s)</td><td>Whole-CPU maximum memory bandwidth, read : write = 2 : 1.</td></tr><tr><td>cpu-memory-bw-latency/mem_max_bandwidth_1_1_reads-writes_bw</td><td>bandwidth (MB/s)</td><td>Whole-CPU maximum memory bandwidth, read : write = 1 : 1.</td></tr><tr><td>cpu-memory-bw-latency/mem_max_bandwidth_stream-triad_like_bw</td><td>bandwidth (MB/s)</td><td>Whole-CPU maximum memory bandwidth, with stream-triad like pattern.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="mem-bw"></a><code>mem-bw</code><a class="hash-link" href="#mem-bw" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-12"></a>Introduction<a class="hash-link" href="#introduction-12" title="Direct link to heading">#</a></h4><p>Measure the memory copy bandwidth across PCI-e and memory copy bandwidth between GPUs,
performed by <a href="https://github.com/NVIDIA/cuda-samples/tree/master/Samples/1_Utilities/bandwidthTest" target="_blank" rel="noopener noreferrer">NVIDIA</a>
or <a href="https://github.com/ROCm-Developer-Tools/HIP/tree/master/samples/1_Utils/hipBusBandwidth" target="_blank" rel="noopener noreferrer">AMD</a> bandwidth test tool.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-12"></a>Metrics<a class="hash-link" href="#metrics-12" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>mem-bw/h2d_bw</td><td>bandwidth (GB/s)</td><td>Host to device copy bandwidth.</td></tr><tr><td>mem-bw/d2h_bw</td><td>bandwidth (GB/s)</td><td>Device to host copy bandwidth.</td></tr><tr><td>mem-bw/d2d_bw</td><td>bandwidth (GB/s)</td><td>Device to device copy bandwidth.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="gpu-copy-bw"></a><code>gpu-copy-bw</code><a class="hash-link" href="#gpu-copy-bw" title="Direct link to heading">#</a></h3><p>Measure the memory copy bandwidth performed by GPU SM/DMA engine, including device-to-host, host-to-device and device-to-device.
For measurements of peer-to-peer communication performance between AMD GPUs, GPU memory buffers are allocated in <code>hipDeviceMallocUncached</code> (previous <code>hipDeviceMallocFinegrained</code>) mode to maximize performance.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-13"></a>Metrics<a class="hash-link" href="#metrics-13" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>cpu_to_gpu[0-9]+_by_(sm|dma)_under_numa[0-9]+_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of one GPU reading one NUMA node&#x27;s host memory using DMA engine or GPU SM.</td></tr><tr><td>gpu[0-9]+_to_cpu_by_(sm|dma)_under_numa[0-9]+_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of one GPU writing one NUMA node&#x27;s host memory using DMA engine or GPU SM.</td></tr><tr><td>gpu[0-9]+_to_gpu[0-9]+_by_(sm|dma)_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of one GPU reading or writing self&#x27;s memory using DMA engine or GPU SM.</td></tr><tr><td>gpu[0-9]+_to_gpu[0-9]+_(read|write)_by_(sm|dma)_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of one GPU reading or writing peer GPU&#x27;s memory using DMA engine or GPU SM with peer communication enabled.</td></tr><tr><td>cpu_and_gpu[0-9]+_by_(sm|dma)_under_numa[0-9]+_bw</td><td>bandwidth (GB/s)</td><td>The bidirectional bandwidth of one GPU reading and writing one NUMA node&#x27;s host memory using DMA engine or GPU SM.</td></tr><tr><td>gpu[0-9]+_and_cpu_by_(sm|dma)_under_numa[0-9]+_bw</td><td>bandwidth (GB/s)</td><td>Same as above, but generated by --dtoh --bidirectional.</td></tr><tr><td>gpu[0-9]+_and_gpu[0-9]+_by_(sm|dma)_bw</td><td>bandwidth (GB/s)</td><td>The bidirectional bandwidth of one GPU reading and writing self&#x27;s memory using DMA engine or GPU SM.</td></tr><tr><td>gpu[0-9]+_and_gpu[0-9]+_(read|write)_by_(sm|dma)_bw</td><td>bandwidth (GB/s)</td><td>The bidirectional bandwidth of one GPU reading and writing peer GPU&#x27;s memory using DMA engine or GPU SM with peer communication enabled.</td></tr><tr><td>gpu[0-9]+_to_gpu_all_write_by_sm_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of one GPU writing all peer GPUs&#x27; memory using GPU SM with peer communication enabled.</td></tr><tr><td>gpu_all_to_gpu[0-9]+_write_by_sm_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of all peer GPUs writing one GPU&#x27;s memory using GPU SM with peer communication enabled.</td></tr><tr><td>gpu_all_to_gpu_all_write_by_sm_bw</td><td>bandwidth (GB/s)</td><td>The unidirectional bandwidth of all peer GPUs writing all peer GPUs&#x27; memory using GPU SM with peer communication enabled.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ib-loopback"></a><code>ib-loopback</code><a class="hash-link" href="#ib-loopback" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-13"></a>Introduction<a class="hash-link" href="#introduction-13" title="Direct link to heading">#</a></h4><p>Measure the InfiniBand loopback verbs bandwidth, performed by
<a href="https://github.com/linux-rdma/perftest/tree/7504ce48ac396a02f4d00de359257b2cb8458f06" target="_blank" rel="noopener noreferrer">OFED performance tests</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-14"></a>Metrics<a class="hash-link" href="#metrics-14" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>ib-loopback/ib<em>write_bw</em>${msg_size}</td><td>bandwidth (GB/s)</td><td>InfiniBand loopback write bandwidth with given message size.</td></tr><tr><td>ib-loopback/ib<em>read_bw</em>${msg_size}</td><td>bandwidth (GB/s)</td><td>InfiniBand loopback read bandwidth with given message size.</td></tr><tr><td>ib-loopback/ib<em>send_bw</em>${msg_size}</td><td>bandwidth (GB/s)</td><td>InfiniBand loopback send bandwidth with given message size.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="nccl-bw--rccl-bw"></a><code>nccl-bw</code> / <code>rccl-bw</code><a class="hash-link" href="#nccl-bw--rccl-bw" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-14"></a>Introduction<a class="hash-link" href="#introduction-14" title="Direct link to heading">#</a></h4><p>Measure the performance of NCCL/RCCL operations under multi nodes&#x27; traffic pattern,
performed by <a href="https://github.com/NVIDIA/nccl-tests/tree/44df0bf010dcc95e840ca0fb7466c67cff3f1f0f" target="_blank" rel="noopener noreferrer">nccl-tests</a>
or <a href="https://github.com/ROCmSoftwarePlatform/rccl-tests/tree/dc1ad4853d7ec738387d42a75a58a98d7af00c7b" target="_blank" rel="noopener noreferrer">rccl-tests</a>.
Support the following operations currently: allreduce, allgather, broadcast, reduce, reducescatter, alltoall.
Support both in-place and out-of-place measurements.</p><p>Support the following traffic patterns:</p><ul><li><code>all-nodes</code>, validate the NCCL/RCCL performance across all VM nodes simultaneously.</li><li><code>pair-wise</code>, validate the NCCL/RCCL performance across VM pairs with all possible combinations in parallel.</li><li><code>k-batch</code>, validate the NCCL/RCCL performance across VM groups with a specified batch scale.</li><li><code>topo-aware</code>, validate the NCCL/RCCL performance across VM pairs with different distances/hops as a quick test.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-15"></a>Metrics<a class="hash-link" href="#metrics-15" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>nccl-bw/${operation}_${msg_size}_time</td><td>time (us)</td><td>NCCL operation lantency with given message size.</td></tr><tr><td>nccl-bw/${operation}_${msg_size}_algbw</td><td>bandwidth (GB/s)</td><td>NCCL operation algorithm bandwidth with given message size.</td></tr><tr><td>nccl-bw/${operation}_${msg_size}_busbw</td><td>bandwidth (GB/s)</td><td>NCCL operation bus bandwidth with given message size.</td></tr><tr><td>rccl-bw/${operation}_${msg_size}_time</td><td>time (us)</td><td>RCCL operation lantency with given message size.</td></tr><tr><td>rccl-bw/${operation}_${msg_size}_algbw</td><td>bandwidth (GB/s)</td><td>RCCL operation algorithm bandwidth with given message size.</td></tr><tr><td>rccl-bw/${operation}_${msg_size}_busbw</td><td>bandwidth (GB/s)</td><td>RCCL operation bus bandwidth with given message size.</td></tr></tbody></table><p>If mpi mode is enable and traffic pattern is specified, the metrics pattern will change to <code>nccl-bw/${operation}_${serial_index)_${parallel_index):${msg_size}_time</code></p><ul><li><code>serial_index</code> represents the serial index of the host group in serial.</li><li><code>parallel_index</code> represents the parallel index of the host list in parallel.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="tcp-connectivity"></a><code>tcp-connectivity</code><a class="hash-link" href="#tcp-connectivity" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-15"></a>Introduction<a class="hash-link" href="#introduction-15" title="Direct link to heading">#</a></h4><p>Test the TCP connectivity between current node and nodes in the hostfile,
performed by <a href="https://github.com/zhengxiaowai/tcping" target="_blank" rel="noopener noreferrer">tcping</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-16"></a>Metrics<a class="hash-link" href="#metrics-16" title="Direct link to heading">#</a></h4><table><thead><tr><th>Metrics</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>tcp-connectivity/${hostname/ip}_successed_count</td><td>count</td><td>successed times of tcp connections between current node and other nodes</td></tr><tr><td>tcp-connectivity/${hostname/ip}_failed_count</td><td>count</td><td>failed times of tcp connections between current node and other nodes</td></tr><tr><td>tcp-connectivity/${hostname/ip}_success_rate</td><td></td><td>success rate (successed/total) of tcp connection between current node and other nodes</td></tr><tr><td>tcp-connectivity/${hostname/ip}_time_min</td><td>time (ms)</td><td>mininum latency of tcp connections between current node and other nodes</td></tr><tr><td>tcp-connectivity/${hostname/ip}_time_max</td><td>time (ms)</td><td>maximum latency of tcp connections between current node and other nodes</td></tr><tr><td>tcp-connectivity/${hostname/ip}_time_avg</td><td>time (ms)</td><td>average latency of tcp connections between current node and other nodes</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="gpcnet-network-test--gpcnet-network-load-test"></a><code>gpcnet-network-test</code> / <code>gpcnet-network-load-test</code><a class="hash-link" href="#gpcnet-network-test--gpcnet-network-load-test" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-16"></a>Introduction<a class="hash-link" href="#introduction-16" title="Direct link to heading">#</a></h4><p>Distributed test, test the global network performance and congestion,
performed by <a href="https://github.com/netbench/GPCNET" target="_blank" rel="noopener noreferrer">GPCNET</a></p><p>gpcnet-network-test: Full system network tests in random and natural ring, alltoall and allreduce, at least 2 nodes</p><p>gpcnet-network-load-test: Select full system network tests run with four congestors to measure network congestion or contention, at least 10 nodes</p><ul><li>supporting network tests: RR Two-sided Lat (8 B), RR Get Lat (8 B), RR Two-sided BW (131072 B), RR Put BW (131072 B), RR Two-sided BW+Sync (131072 B), Nat Two-sided BW (131072 B), Multiple Allreduce (8 B), Multiple Alltoall (4096 B)</li><li>supporting congestors: Alltoall (4096 B), Two-sided Incast (4096 B), Put Incast (4096 B), Get Bcast (4096 B)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-17"></a>Metrics<a class="hash-link" href="#metrics-17" title="Direct link to heading">#</a></h4><table><thead><tr><th>Metrics</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>gpcnet-network-test/rr<em>two-sided_lat</em>${stat}</td><td>time (us)</td><td>statistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;random ring communication pattern two-side latency&#x27; for network testing</td></tr><tr><td>gpcnet-network-test/rr<em>two-sided+sync_bw</em>${stat}</td><td>bandwidth (MiB/s/rank)</td><td>fstatistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;random ring communication pattern two-side bandwidth with barrier&#x27; for network testing</td></tr><tr><td>gpcnet-network-test/multiple<em>allreduce_time</em>${stat}</td><td>time (us)</td><td>statistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;multiple allreduce bandwidth&#x27; for network testing</td></tr><tr><td>gpcnet-network-test/rr<em>get_lat</em>${stat}</td><td>bandwidth (MiB/s/rank)</td><td>statistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;RR GetLat (8 B)&#x27; for network testing</td></tr><tr><td>gpcnet-network-test/rr<em>two-sided_bw</em>${stat}</td><td>bandwidth (MiB/s/rank)</td><td>statistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;RR Two-sidedBW (131072 B)&#x27; for network testing</td></tr><tr><td>gpcnet-network-test/nat<em>two-sided_bw</em>${stat}</td><td>bandwidth (MiB/s/rank)</td><td>statistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;Nat Two-sidedBW (131072 B)&#x27; for network testing</td></tr><tr><td>gpcnet-network-test/multiple<em>alltoall_bw</em>${stat}</td><td>bandwidth (MiB/s/rank)</td><td>statistical values(min, max, avg, 99%, 99.9%) obtained by all nodes use algorithm &#x27;Multiple Alltoall (4096 B)&#x27; for network testing</td></tr><tr><td>gpcnet-network-load-test/rr<em>two-sided_lat_x</em>${stat}</td><td>factor (x)</td><td>summary about congestion impact factor of the network test algorithm</td></tr><tr><td>gpcnet-network-load-test/rr<em>two-sided+sync_bw_x</em>${stat}</td><td>factor (x)</td><td>summary about congestion impact factor of the network test algorithm</td></tr><tr><td>gpcnet-network-load-test/multiple<em>allreduce_x</em>${stat}</td><td>factor (x)</td><td>summary about congestion impact factor of the network test algorithm</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ib-traffic"></a><code>ib-traffic</code><a class="hash-link" href="#ib-traffic" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-17"></a>Introduction<a class="hash-link" href="#introduction-17" title="Direct link to heading">#</a></h4><p>Measure the InfiniBand performance under multi nodes&#x27; traffic pattern.</p><p>The direction between client and server can be &#x27;cpu-to-cpu&#x27;/&#x27;gpu-to-gpu&#x27;/&#x27;gpu-to-cpu&#x27;/&#x27;cpu-to-gpu&#x27;.</p><p>The traffic pattern is defined in a config file, which is pre-defined for one-to-many, many-to-one and all-to-all patterns.
Each row in the config is one round, and all pairs of nodes in a row run ib command simultaneously.</p><p>Besides the above three patterns, ib-traffic also supports topology-aware traffic pattern. To run ib-traffic with topology-aware
pattern, the user needs to specify 3 required (and 2 optional) parameters in YAML config file:</p><ul><li>--pattern	â€ƒ<strong>topo-aware</strong></li><li>--ibstat	â€ƒ<strong>path to ibstat output</strong></li><li>--ibnetdiscover	â€ƒ<strong>path to ibnetdiscover output</strong></li><li>--min_dist	â€ƒ<strong>minimum distance of VM pairs (optional, default 2)</strong></li><li>--max_dist	â€ƒ<strong>maximum distance of VM pairs (optional, default 6)</strong></li></ul><p>Each row in the config file has all VM pairs with a fixed distance (#hops). That&#x27;s by default, 1st, 2nd, 3rd row has all VM pairs
with topology distance of 2, 4, 6, respectively.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-18"></a>Metrics<a class="hash-link" href="#metrics-18" title="Direct link to heading">#</a></h4><table><thead><tr><th>Metrics</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>ib-traffic/ib_write_bw_${msg_size}_${direction}_${line}_${pair}:${server}_${client}</td><td>bandwidth (GB/s)</td><td>The max bandwidth of perftest (ib_write_bw, ib_send_bw, ib_read_bw) using ${msg_size} with ${direction}(&#x27;cpu-to-cpu&#x27;/&#x27;gpu-to-gpu&#x27;/&#x27;gpu-to-cpu&#x27;/&#x27;cpu-to-gpu&#x27;) run between the ${pair}<sup>th</sup> node pair in the ${line}<sup>th</sup> line of the config, ${server} and ${client} are the hostname of server and client.</td></tr><tr><td>ib-traffic/ib_write_lat_${msg_size}_${direction}_${line}_${pair}:${server}_${client}</td><td>time (us)</td><td>The max latency of perftest (ib_write_lat, ib_send_lat, ib_read_lat) using ${msg_size} with ${direction}(&#x27;cpu-to-cpu&#x27;/&#x27;gpu-to-gpu&#x27;/&#x27;gpu-to-cpu&#x27;/&#x27;cpu-to-gpu&#x27;) run between the ${pair}<sup>th</sup> node pair in the ${line}<sup>th</sup> line of the config, ${server} and ${client} are the hostname of server and client.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="nvbandwidth"></a><code>nvbandwidth</code><a class="hash-link" href="#nvbandwidth" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-18"></a>Introduction<a class="hash-link" href="#introduction-18" title="Direct link to heading">#</a></h4><p>Measures bandwidth and latency for various memcpy patterns across different links using copy engine or kernel copy methods,
performed by <a href="https://github.com/NVIDIA/nvbandwidth" target="_blank" rel="noopener noreferrer">nvbandwidth</a></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-19"></a>Metrics<a class="hash-link" href="#metrics-19" title="Direct link to heading">#</a></h4><table><thead><tr><th>Metrics</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>host_to_device_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Host to device CE memcpy using cuMemcpyAsync</td></tr><tr><td>host_to_device_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_host_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Device to host CE memcpy using cuMemcpyAsync</td></tr><tr><td>device_to_host_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_to_device_bidirectional_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>A host to device copy is measured while a device to host copy is run simultaneously. Only the host to device copy bandwidth is reported.</td></tr><tr><td>host_to_device_bidirectional_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_host_bidirectional_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>A device to host copy is measured while a host to device copy is run simultaneously. Only the device to host copy bandwidth is reported.</td></tr><tr><td>device_to_host_bidirectional_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_memcpy_read_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of cuMemcpyAsync between each pair of accessible peers. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>device_to_device_memcpy_read_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_memcpy_write_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of cuMemcpyAsync between each pair of accessible peers. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>device_to_device_memcpy_write_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_bidirectional_memcpy_read_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of cuMemcpyAsync between each pair of accessible peers. A copy in the opposite direction of the measured copy is run simultaneously but not measured. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>device_to_device_bidirectional_memcpy_read_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_bidirectional_memcpy_write_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of cuMemcpyAsync between each pair of accessible peers. A copy in the opposite direction of the measured copy is run simultaneously but not measured. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>device_to_device_bidirectional_memcpy_write_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_host_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of cuMemcpyAsync between a single device and the host while simultaneously running copies from all other devices to the host.</td></tr><tr><td>all_to_host_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_host_bidirectional_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>A device to host copy is measured while a host to device copy is run simultaneously. Only the device to host copy bandwidth is reported. All other devices generate simultaneous host to device and device to host interfering traffic.</td></tr><tr><td>all_to_host_bidirectional_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_to_all_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of cuMemcpyAsync between the host to a single device while simultaneously running copies from the host to all other devices.</td></tr><tr><td>host_to_all_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_to_all_bidirectional_memcpy_ce_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>A host to device copy is measured while a device to host copy is run simultaneously. Only the host to device copy bandwidth is reported. All other devices generate simultaneous host to device and device to host interfering traffic.</td></tr><tr><td>host_to_all_bidirectional_memcpy_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_one_write_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from all accessible peers to a single device, for each device. Bandwidth is reported as the total inbound bandwidth for each device. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>all_to_one_write_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_one_read_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from all accessible peers to a single device, for each device. Bandwidth is reported as the total outbound bandwidth for each device. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>all_to_one_read_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>one_to_all_write_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from a single device to all accessible peers, for each device. Bandwidth is reported as the total outbound bandwidth for each device. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>one_to_all_write_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>one_to_all_read_ce_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from a single device to all accessible peers, for each device. Bandwidth is reported as the total inbound bandwidth for each device. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>one_to_all_read_ce_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_to_device_memcpy_sm_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Host to device SM memcpy using a copy kernel</td></tr><tr><td>host_to_device_memcpy_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_host_memcpy_sm_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Device to host SM memcpy using a copy kernel</td></tr><tr><td>device_to_host_memcpy_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_memcpy_read_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of a copy kernel between each pair of accessible peers. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>device_to_device_memcpy_read_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_memcpy_write_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of a copy kernel between each pair of accessible peers. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>device_to_device_memcpy_write_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_bidirectional_memcpy_read_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of a copy kernel between each pair of accessible peers. Copies are run in both directions between each pair, and the sum is reported. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>device_to_device_bidirectional_memcpy_read_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_bidirectional_memcpy_write_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of a copy kernel between each pair of accessible peers. Copies are run in both directions between each pair, and the sum is reported. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>device_to_device_bidirectional_memcpy_write_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_host_memcpy_sm_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of a copy kernel between a single device and the host while simultaneously running copies from all other devices to the host.</td></tr><tr><td>all_to_host_memcpy_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_host_bidirectional_memcpy_sm_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>A device to host bandwidth of a copy kernel is measured while a host to device copy is run simultaneously. Only the device to host copy bandwidth is reported. All other devices generate simultaneous host to device and device to host interfering traffic using copy kernels.</td></tr><tr><td>all_to_host_bidirectional_memcpy_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_to_all_memcpy_sm_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures bandwidth of a copy kernel between the host to a single device while simultaneously running copies from the host to all other devices.</td></tr><tr><td>host_to_all_memcpy_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_to_all_bidirectional_memcpy_sm_cpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>A host to device bandwidth of a copy kernel is measured while a device to host copy is run simultaneously. Only the host to device copy bandwidth is reported. All other devices generate simultaneous host to device and device to host interfering traffic using copy kernels.</td></tr><tr><td>host_to_all_bidirectional_memcpy_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_one_write_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from all accessible peers to a single device, for each device. Bandwidth is reported as the total inbound bandwidth for each device. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>all_to_one_write_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>all_to_one_read_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from all accessible peers to a single device, for each device. Bandwidth is reported as the total outbound bandwidth for each device. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>all_to_one_read_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>one_to_all_write_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from a single device to all accessible peers, for each device. Bandwidth is reported as the total outbound bandwidth for each device. Write tests launch a copy from the target device to the peer using the target&#x27;s context.</td></tr><tr><td>one_to_all_write_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>one_to_all_read_sm_gpu[0-9]_gpu[0-9]_bw</td><td>GB/s</td><td>Measures the total bandwidth of copies from a single device to all accessible peers, for each device. Bandwidth is reported as the total inbound bandwidth for each device. Read tests launch a copy from the peer device to the target using the target&#x27;s context.</td></tr><tr><td>one_to_all_read_sm_sum_bw</td><td>GB/s</td><td>Sum of the output matrix</td></tr><tr><td>host_device_latency_sm_cpu[0-9]_gpu[0-9]_lat</td><td>Âµs</td><td>Host - device SM copy latency using a ptr chase kernel</td></tr><tr><td>host_device_latency_sm_sum_lat</td><td>Âµs</td><td>Sum of the output matrix</td></tr><tr><td>device_to_device_latency_sm_gpu[0-9]_gpu[0-9]_lat</td><td>Âµs</td><td>Measures latency of a pointer dereference operation between each pair of accessible peers. Memory is allocated on a GPU and is accessed by the peer GPU to determine latency.</td></tr><tr><td>device_to_device_latency_sm_sum_lat</td><td>Âµs</td><td>Sum of the output matrix</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="computation-communication-benchmarks"></a>Computation-communication Benchmarks<a class="hash-link" href="#computation-communication-benchmarks" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="computation-communication-overlap"></a><code>computation-communication-overlap</code><a class="hash-link" href="#computation-communication-overlap" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-19"></a>Introduction<a class="hash-link" href="#introduction-19" title="Direct link to heading">#</a></h4><p>Test the performance of single node when communication and computation overlap.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-20"></a>Metrics<a class="hash-link" href="#metrics-20" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>pytorch-computation-communication-overlap/mul_time</td><td>time (ms)</td><td>Time of communication and mul kernel computation overlap.</td></tr><tr><td>pytorch-computation-communication-overlap/matmul_time</td><td>time (ms)</td><td>Time of communication and matmul kernel computation overlap.</td></tr></tbody></table><h4></h4><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="sharding-matmul"></a><code>sharding-matmul</code><a class="hash-link" href="#sharding-matmul" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-20"></a>Introduction<a class="hash-link" href="#introduction-20" title="Direct link to heading">#</a></h4><p>Test the performance of large scale matmul operation with multiple GPUs:</p><ul><li>allreduce: Each GPU will calculate part of the MM calculation, and use AllReduce to merge all data into one tensor.</li><li>allgather: Each GPU will calculate part of the MM calculation, and use AllGather + Concat to merge all data into one tensor.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-21"></a>Metrics<a class="hash-link" href="#metrics-21" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>pytorch-sharding-matmul/allreduce_time</td><td>time (ms)</td><td>Time of sharding matmul using allreduce.</td></tr><tr><td>pytorch-sharding-matmul/allgather_time</td><td>time (ms)</td><td>Time of sharding matmul using allgather.</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="dist-inference"></a><code>dist-inference</code><a class="hash-link" href="#dist-inference" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-21"></a>Introduction<a class="hash-link" href="#introduction-21" title="Direct link to heading">#</a></h4><p>Test the performance of distributed model inference. Support both PyTorch implementation and cpp implementation.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-22"></a>Metrics<a class="hash-link" href="#metrics-22" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>pytorch-dist-inference/step_times</td><td>time (ms)</td><td>Average time of model inference runs.</td></tr><tr><td>pytorch-dist-inference/step<em>times</em>${percentile}</td><td>time (ms)</td><td>Tail (50,90,95,99,99.9) time of model inference runs.</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="storage-benchmarks"></a>Storage Benchmarks<a class="hash-link" href="#storage-benchmarks" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="disk-benchmark"></a><code>disk-benchmark</code><a class="hash-link" href="#disk-benchmark" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="introduction-22"></a>Introduction<a class="hash-link" href="#introduction-22" title="Direct link to heading">#</a></h4><p>Measure the disk performance through <a href="https://github.com/axboe/fio/tree/0313e938c9c8bb37d71dade239f1f5326677b079" target="_blank" rel="noopener noreferrer">FIO</a>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="metrics-23"></a>Metrics<a class="hash-link" href="#metrics-23" title="Direct link to heading">#</a></h4><table><thead><tr><th>Name</th><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>disk-benchmark/${disk_name}_rand_read_write_bs</td><td>size (bytes)</td><td>Disk random read write block size.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_read_iops</td><td>IOPS</td><td>Disk random read write read IOPS.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_read_lat_ns_95.0</td><td>time (ns)</td><td>Disk random read write read latency in 95.0 percentile.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_read_lat_ns_99.0</td><td>time (ns)</td><td>Disk random read write read latency in 99.0 percentile.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_read_lat_ns_99.9</td><td>time (ns)</td><td>Disk random read write read latency in 99.9 percentile.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_write_iops</td><td>IOPS</td><td>Disk random read write write IOPS.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_write_lat_ns_95.0</td><td>time (ns)</td><td>Disk random read write write latency in 95.0 percentile.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_write_lat_ns_99.0</td><td>time (ns)</td><td>Disk random read write write latency in 99.0 percentile.</td></tr><tr><td>disk-benchmark/${disk_name}_rand_read_write_write_lat_ns_99.9</td><td>time (ns)</td><td>Disk random read write write latency in 99.9 percentile.</td></tr></tbody></table></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/microsoft/superbenchmark/edit/main/website/../docs/user-tutorial/benchmarks/micro-benchmarks.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_wj+Z"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/superbenchmark/docs/getting-started/run-superbench"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Run SuperBench</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/superbenchmark/docs/user-tutorial/benchmarks/model-benchmarks"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Model Benchmarks Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#computation-benchmarks" class="table-of-contents__link">Computation Benchmarks</a><ul><li><a href="#kernel-launch" class="table-of-contents__link"><code>kernel-launch</code></a></li><li><a href="#gemm-flops" class="table-of-contents__link"><code>gemm-flops</code></a></li><li><a href="#matmul" class="table-of-contents__link"><code>matmul</code></a></li><li><a href="#cublaslt-gemm--hipblaslt-gemm" class="table-of-contents__link"><code>cublaslt-gemm</code> / <code>hipblaslt-gemm</code></a></li><li><a href="#cublas-function" class="table-of-contents__link"><code>cublas-function</code></a></li><li><a href="#cudnn-function" class="table-of-contents__link"><code>cudnn-function</code></a></li><li><a href="#tensorrt-inference" class="table-of-contents__link"><code>tensorrt-inference</code></a></li><li><a href="#ort-inference" class="table-of-contents__link"><code>ort-inference</code></a></li><li><a href="#gpu-burn" class="table-of-contents__link"><code>gpu-burn</code></a></li><li><a href="#cpu-hpl" class="table-of-contents__link"><code>cpu-hpl</code></a></li><li><a href="#cpu-stream" class="table-of-contents__link"><code>cpu-stream</code></a></li></ul></li><li><a href="#communication-benchmarks" class="table-of-contents__link">Communication Benchmarks</a><ul><li><a href="#cpu-memory-bw-latency" class="table-of-contents__link"><code>cpu-memory-bw-latency</code></a></li><li><a href="#mem-bw" class="table-of-contents__link"><code>mem-bw</code></a></li><li><a href="#gpu-copy-bw" class="table-of-contents__link"><code>gpu-copy-bw</code></a></li><li><a href="#ib-loopback" class="table-of-contents__link"><code>ib-loopback</code></a></li><li><a href="#nccl-bw--rccl-bw" class="table-of-contents__link"><code>nccl-bw</code> / <code>rccl-bw</code></a></li><li><a href="#tcp-connectivity" class="table-of-contents__link"><code>tcp-connectivity</code></a></li><li><a href="#gpcnet-network-test--gpcnet-network-load-test" class="table-of-contents__link"><code>gpcnet-network-test</code> / <code>gpcnet-network-load-test</code></a></li><li><a href="#ib-traffic" class="table-of-contents__link"><code>ib-traffic</code></a></li><li><a href="#nvbandwidth" class="table-of-contents__link"><code>nvbandwidth</code></a></li></ul></li><li><a href="#computation-communication-benchmarks" class="table-of-contents__link">Computation-communication Benchmarks</a><ul><li><a href="#computation-communication-overlap" class="table-of-contents__link"><code>computation-communication-overlap</code></a></li><li><a href="#sharding-matmul" class="table-of-contents__link"><code>sharding-matmul</code></a></li><li><a href="#dist-inference" class="table-of-contents__link"><code>dist-inference</code></a></li></ul></li><li><a href="#storage-benchmarks" class="table-of-contents__link">Storage Benchmarks</a><ul><li><a href="#disk-benchmark" class="table-of-contents__link"><code>disk-benchmark</code></a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/superbenchmark/docs/introduction">Introduction</a></li><li class="footer__item"><a class="footer__link-item" href="/superbenchmark/docs/getting-started/installation">Getting Started</a></li><li class="footer__item"><a class="footer__link-item" href="/superbenchmark/docs/cli">API</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/microsoft/superbenchmark/issues" target="_blank" rel="noopener noreferrer" class="footer__link-item">Issues</a></li><li class="footer__item"><a href="https://github.com/microsoft/superbenchmark/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discussion</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/superbenchmark/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/microsoft/superbenchmark" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2024 SuperBench. <br> Built with Docusaurus and hosted by GitHub.</div></div></div></footer></div>
<script src="/superbenchmark/assets/js/runtime~main.45f631de.js"></script>
<script src="/superbenchmark/assets/js/main.74900b60.js"></script>
</body>
</html>