# debug, func def

import re
import os
import json
from enum import Enum
from InfraDio.utils import *

## funcs used in gen report

### define the structure of the report

class SectionCategory(Enum):
    # takes 1 input from prompt.case folder, use python to convert:
    ## title, author, date, appendix
    
    # takes 2 inputs from prompt.case_target_baseline folder and prompt.report folder, use LLM to convert:
    ## benchmark
    
    # takes 2 inputs from prompt.report and output of benchmark, use LLM to convert:
    ## es, conclusion
    
    # spacer is only used to combine into the final main tex
    
    title = "title"
    author = "author"
    date = "date"
    es = "es"
    benchmark = "benchmark"
    conclusion = "conclusion"
    spacer = "spacer"
    appendix = "appendix"
    table = "table"
    manual = "manual"

def create_section(sec_id, sec_shortname, sec_category = SectionCategory.benchmark):
    section = {
        "section_id": sec_id,                   # the index in integer, in the order of reading the report
        "shortname": sec_shortname,             # short name, user defined
        "category": str(sec_category.value),    # category of this section, refer to class SectionCategory for available values
        "comment": "",                          # only for debug
        "content": ""                           # the content of this section, generated by InfraWise
    } 
    return section

def append_section(section, subsection):
    section_copy = section.copy()
    if "subsections" not in section_copy:
        section_copy["subsections"] = []  # initialize subsections as an empty list if it doesn't exist
    section_copy["subsections"].append(subsection)  # append new subsection to the list
    return section_copy

## funcs used in combine report
def extract_tables_from_case(content):
    lines = content.splitlines()

    # regex pattern for the table
    pattern = r"([^|]\n\|.*?\|.*?\d+.*?\|\n[^|])"

    # use re.DOTALL to make '.' match any character including newlines
    matches = re.finditer(pattern, content, re.DOTALL)

    title_list=[]
    table_list=[]
    for i, match in enumerate(matches, 1):
        # get the starting position of the match
        start = match.start()
        # count the number of newline characters before the start of the match
        line_number = content[:start].count('\n') + 1    
        title_list.append(lines[line_number-1])
        
        table = match.group()[1:-1]
        table_list.append(table)
        
    return title_list, table_list

def write_tables_from_case(sec_title, case_file_path, report_file_path):
    with open(f"{case_file_path}/{sec_title}.md", "r") as file:
        content = file.read()
        
    title_list, table_list = extract_tables_from_case(content)

    with open(f"{report_file_path}/{sec_title}.md", "a") as file:
            file.write(f"\n## Benchmark Performance Table\n")

    for title, table in zip(title_list, table_list):
        print(report_file_path)
        with open(f"{report_file_path}/{sec_title}.md", "a") as file:
            file.write(f"### {title}\n")
            file.write(f"{table}\n")

def check_string_existence(my_string, my_list):
    return any(my_string in s for s in my_list)

def adjust_heading_level(text, adjustment=1):
    lines = text.split('\n')
    for i, line in enumerate(lines):
        count = 0
        while count < len(line) and line[count] == '#':
            count += 1
        if count > 0:
            lines[i] = '#' * adjustment + line
    return '\n'.join(lines)

def extract_dcw_entries(SKU_SET, entry_file):
    with open(entry_file, 'r') as f:
        entries = json.load(f)

    # travers entries
    for entry in entries:
        # print(entry)    
        if entry["SKU_SET"] == SKU_SET:
            dcw_str = entry["dcw_str"]
            SKUNickName = entry["SKUNickName"]
            print(f'SKU_SET found')
            break
        else:
            dcw_str = ''
            SKUNickName = ''
            print(f'no matching SKU_SET, please run manual check')

    return dcw_str, SKUNickName